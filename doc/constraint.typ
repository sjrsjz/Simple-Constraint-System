= 基于集合论的约束系统


== 约束

当我们引入约束时，我们实际上是在定义一个子集，这个子集包含了满足特定条件的所有元素。
例如，约束 $C$ 可以定义为一个集合，其中包含所有满足某个条件的元素。

由此引入超约束的概念，超约束是对约束的更弱的限制，意味着它允许更多的元素满足条件，从而形成一个更大的集合。

我们记 $"Set"(C)$ 为约束 $C$ 所定义的集合。则定义超约束为

$ A >= B <=> "Set"(A) supset "Set"(B) $

定义全等为

$ A eq.triple B <=> A >= B and A <= B $

=== 无约束（全集）

无约束意味着没有任何限制或条件，这也意味着任何值都隶属于这个集合。
在这种情况下，全集是所有可能值的集合，即 $"T"$ (True)。

=== 完全约束（空集）
完全约束意味着所有值都不满足约束条件，因此这个集合为空集。即 $"F"$ (False)。

=== 原子约束
原子约束是指仅仅比完全约束少一个约束条件的约束。他们能对应到一个单元素集合上。

例如，整数 $5$ 可以被视为一个单一完全约束 $C_N(5)$，对应到集合 ${5}$。

这意味着对于不同的原子约束，他们的交集一定是空集，即 $F$

=== 有序对

有序对是指两个元素的组合，通常表示为 $(a, b)$，其中 $a$ 和 $b$ 是两个元素。有序对约束也是一个原子约束。


=== 约束的构造

我们使用 $union$ 来拼接原子约束，形成更复杂的约束。使用 $|$ 来表示 Enum

与常规编程语言的类型系统不同，我们的约束系统不采用前向声明的方式（树形），而是采用方程式的方式来定义约束之间的关系。

比如，我们可以定义列表为

$ L_C := C times L_C | "Nil" $

其中 "Nil" 是一个特殊的原子约束，表示终结符。

这使得我们的约束实际的储存方式是一个有向图，左端的名称唯一确定了约束图的入口点（起始遍历位置）

我们可以使用互模拟的方式来判定约束之间的关系。

例如判定 $L_T := T times L_T | "Nil"$ 是 $L_C := C times L_C | "Nil"$ 的超约束，其中 $|$ 是 Enum